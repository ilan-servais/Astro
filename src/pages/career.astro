---
import Layout from '@layouts/Layout.astro';
import TimelineExperience from '@components/TimelineExperience.astro';
import timelineData from '../data/timeline.json';
import BackToTop from '@components/ui/BackToTop.astro';

// Tri des expériences par année du plus récent au plus ancien
const sortedExperiences = [...timelineData.experiences].sort((a, b) => {
  const extractYear = (yearStr) => {
    if (typeof yearStr === 'string') {
      const match = yearStr.match(/^\d{4}/);
      return match ? parseInt(match[0]) : 0;
    }
    return yearStr;
  };
  
  return extractYear(b.year) - extractYear(a.year);
});

// Récupérer l'ID de l'URL hash côté serveur si possible
const initialId = Astro.url.hash ? Astro.url.hash.substring(1) : "1";
---

<Layout title="Ilan Servais | Professional Career">
  <main class="mx-auto max-w-4xl px-4">
    <div class="text-center py-8">
      <h1 class="font-monospace text-3xl text-orange mb-6">My Career Path</h1>
    </div>

    <div class="space-y-12 pb-20">
      {sortedExperiences.map((exp) => (
        <div 
          id={exp.id.toString()} 
          class={`card-container group relative ${exp.id.toString() === initialId ? 'active' : ''}`} 
          data-exp-id={exp.id}
        >
          <TimelineExperience 
            id={exp.id}
            year={exp.year}
            company={exp.company}
            title={exp.title}
            description={exp.description}
            iconPath={exp.iconPath}
            city={exp.city}
          />
        </div>
      ))}
    </div>
    
    <div class="fixed bottom-5 right-5 z-50">
      <BackToTop />
    </div>
  </main>
</Layout>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    // Drapeaux pour gérer le deep linking et l'état
    let deepLinkActive = !!window.location.hash;
    let hasScrolled = false;
    let lastActiveId = window.location.hash ? window.location.hash.substring(1) : '1';
    
    // Variable pour suivre le défilement
    let isScrolling = false;
    let scrollTimeout;
    let lastScrollPosition = window.scrollY;
    
    // Ratios de la hauteur de la fenêtre pour le déclenchement
    const topTriggerRatio = 0.35;     // Abaissé à 35% du haut pour résoudre le problème
    const bottomTriggerRatio = 0.65;  // Augmenté à 65% pour plus de marge
    
    // Fonction pour activer une carte sans déclencher de défilement
    function activateCard(id, scroll = false) {
      // Ne rien faire si c'est la même carte et qu'elle est déjà active
      if (id === lastActiveId && document.getElementById(id)?.classList.contains('active')) return;
      
      // Désactiver toutes les cartes
      document.querySelectorAll('.card-container').forEach(container => {
        container.classList.remove('active');
      });
      
      // Activer la carte cible
      const targetCard = document.getElementById(id);
      if (targetCard) {
        targetCard.classList.add('active');
        lastActiveId = id;
        
        // Mettre à jour l'URL sans déclencher de rechargement
        if (history.replaceState) {
          history.replaceState(null, null, `#${id}`);
        }
        
        // Faire défiler jusqu'à la carte si demandé
        if (scroll) {
          // Utiliser une méthode de défilement plus fiable pour Chrome
          const yOffset = -80; // Décalage pour éviter que la carte soit complètement en haut
          const y = targetCard.getBoundingClientRect().top + window.pageYOffset + yOffset;
          
          window.scrollTo({
            top: y,
            behavior: 'smooth'
          });
          
          // Désactiver la détection de scroll pendant l'animation
          hasScrolled = true;
          setTimeout(() => { hasScrolled = false; }, 1000);
        }
      }
    }
    
    // Activation initiale au chargement avec un délai pour assurer le rendu complet
    if (!window.location.hash) {
      setTimeout(() => activateCard('1', false), 150);
    } else {
      const idFromHash = window.location.hash.substring(1);
      // Délai pour s'assurer que le DOM est complètement chargé
      setTimeout(() => activateCard(idFromHash, true), 150);
    }
    
    // Fonction principale de détection du défilement
    function handleScroll() {
      // Ne pas traiter le défilement si activé par un deep link jusqu'à ce que l'utilisateur fasse défiler manuellement
      if (deepLinkActive) {
        const scrollDelta = Math.abs(window.scrollY - lastScrollPosition);
        if (scrollDelta < 20) return;
        deepLinkActive = false;
      }
      
      // Ne pas traiter pendant le défilement programmé
      if (hasScrolled || isScrolling) return;
      
      // Marquer comme défiant pour éviter de multiples déclenchements
      isScrolling = true;
      
      // Récupérer la position de défilement et la hauteur de la fenêtre
      const scrollPos = window.scrollY;
      const windowHeight = window.innerHeight;
      const documentHeight = document.documentElement.scrollHeight;
      
      // Détection spécifique pour la fin de page (activation de la dernière carte)
      const isNearBottom = (window.innerHeight + window.scrollY) >= document.body.offsetHeight - 100;
      
      if (isNearBottom) {
        // Activer la dernière carte quand on est proche du bas
        const allCards = Array.from(document.querySelectorAll('.card-container'));
        if (allCards.length > 0) {
          const lastCard = allCards[allCards.length - 1];
          const lastCardId = lastCard.getAttribute('data-exp-id');
          activateCard(lastCardId);
        }
        
        // Réinitialiser le drapeau après un léger délai
        setTimeout(() => {
          isScrolling = false;
        }, 100);
        
        return; // Sortir tôt si nous sommes au bas de la page
      }
      
      // Pour le reste du défilement, continuer avec la logique existante
      // Calculer les points de déclenchement
      const triggerTop = windowHeight * topTriggerRatio;
      const triggerBottom = windowHeight * bottomTriggerRatio;
      
      // Récupérer toutes les cartes
      const cards = Array.from(document.querySelectorAll('.card-container'));
      
      // Direction du défilement
      const scrollingDown = scrollPos > lastScrollPosition;
      lastScrollPosition = scrollPos;
      
      // Trouver la carte qui est dans la zone de déclenchement
      let activeCard = null;
      
      for (const card of cards) {
        const rect = card.getBoundingClientRect();
        
        // Déterminer si la carte est dans la zone de déclenchement
        if (scrollingDown) {
          // Pour le défilement vers le bas, vérifier si la carte entre dans la zone de déclenchement par le haut
          if (rect.top <= triggerTop && rect.bottom >= triggerTop) {
            activeCard = card;
            break;
          }
        } else {
          // Pour le défilement vers le haut, vérifier si la carte entre dans la zone de déclenchement par le bas
          if (rect.bottom >= triggerBottom && rect.top <= triggerBottom) {
            activeCard = card;
            break;
          }
        }
      }
      
      // Si aucune carte n'est trouvée mais que nous défilons, trouver la carte la plus visible
      if (!activeCard) {
        let maxVisibility = 0;
        
        for (const card of cards) {
          const rect = card.getBoundingClientRect();
          
          // Calculer la visibilité comme le pourcentage de la carte visible dans la fenêtre
          const visibility = Math.min(rect.bottom, windowHeight) - Math.max(rect.top, 0);
          
          if (visibility > maxVisibility) {
            maxVisibility = visibility;
            activeCard = card;
          }
        }
      }
      
      // Activer la carte trouvée
      if (activeCard) {
        const id = activeCard.getAttribute('data-exp-id');
        activateCard(id);
      }
      
      // Réinitialiser le drapeau après un léger délai pour permettre un nouveau déclenchement
      setTimeout(() => {
        isScrolling = false;
      }, 100);
    }
    
    // Écouteur d'événements de défilement optimisé
    window.addEventListener('scroll', () => {
      // Annuler le timeout précédent
      if (scrollTimeout) {
        clearTimeout(scrollTimeout);
      }
      
      // Définir un nouveau timeout pour ralentir les déclenchements
      scrollTimeout = setTimeout(handleScroll, 50);
    }, { passive: true });
    
    // Réagir au redimensionnement pour recalculer les positions
    window.addEventListener('resize', handleScroll, { passive: true });
    
    // Vérification initiale pour activer la dernière carte si la page est déjà en bas au chargement
    setTimeout(handleScroll, 300);
  });
</script>

<style>
  .card-container {
    transition: all 0.4s ease-out;
    scroll-margin-top: 80px;
    position: relative;
    padding-left: 0;
    border-left: 0px solid transparent;
    will-change: transform, border-left;
  }
  
  /* Animation plus fluide pour l'activation - zoom au lieu de padding */
  .card-container.active {
    border-left: 4px solid #E06330;
    transform: scale(1.02);
    transform-origin: center left;
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.08);
    transition: transform 0.3s ease-out, border-left 0.3s ease-out, box-shadow 0.3s ease-out;
  }
  
  /* Pour un effet plus doux et moins saccadé */
  .timeline-experience {
    transition: transform 0.3s ease;
    transform-origin: left center;
    width: 100%;
  }
  
  /* Stabiliser les éléments internes lors des transitions */
  .timeline-experience > * {
    transform: translateZ(0);
    backface-visibility: hidden;
  }
  
  /* Style pour la notification de copie */
  .copy-notification {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background-color: #333;
    color: white;
    padding: 10px 20px;
    border-radius: 4px;
    z-index: 1000;
    animation: fadeInOut 2s ease;
  }
  
  @keyframes fadeInOut {
    0% { opacity: 0; }
    20% { opacity: 1; }
    80% { opacity: 1; }
    100% { opacity: 0; }
  }
</style>
