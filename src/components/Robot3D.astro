---
import RobotControl from "./ui/RobotControl.astro";
---

<div class="robot-container relative w-full h-screen overflow-hidden">
  <RobotControl />
  
  <div id="robot-scene" class="w-full h-full">
    <!-- Le conteneur pour la scène 3D -->
  </div>
  
  <div id="webgl-error" class="hidden absolute inset-0 bg-black bg-opacity-80 flex items-center justify-center p-4 z-50">
    <div class="bg-[#120D16] border border-[#E06330] p-6 rounded-lg max-w-md text-center">
      <h3 class="text-xl font-bold text-white mb-3">Problème de performance 3D</h3>
      <p class="text-gray-300 mb-4">La visualisation 3D ne fonctionne pas correctement sur votre navigateur.</p>
      <div class="flex space-x-4 justify-center">
        <button id="try-fallback" class="bg-[#E06330] hover:bg-orange-600 text-white px-4 py-2 rounded-md transition-colors">
          Mode simplifié
        </button>
        <button id="close-error" class="bg-gray-700 hover:bg-gray-600 text-white px-4 py-2 rounded-md transition-colors">
          Continuer quand même
        </button>
      </div>
    </div>
  </div>
  
  <script>
    // Exposer les fonctions pour l'interface de contrôle
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import Stats from 'three/addons/libs/stats.module.js';

    let container, stats, clock, mixer, actions, activeAction, previousAction;
    let camera, scene, renderer, model, face;
    let lowPerformanceMode = false;
    let frameCount = 0;
    let lastTime = 0;
    let currentFPS = 0;
    
    // Fonction pour détecter les problèmes de performance
    function checkPerformance() {
      const now = performance.now();
      frameCount++;
      
      // Calculer le FPS toutes les secondes
      if (now - lastTime >= 1000) {
        currentFPS = frameCount;
        frameCount = 0;
        lastTime = now;
        
        // Si le FPS est très bas après quelques secondes, proposer une alternative
        if (currentFPS < 15 && !lowPerformanceMode) {
          document.getElementById('webgl-error').classList.remove('hidden');
        }
      }
    }
    
    // Gestion du message d'erreur
    document.getElementById('close-error').addEventListener('click', () => {
      document.getElementById('webgl-error').classList.add('hidden');
    });
    
    document.getElementById('try-fallback').addEventListener('click', () => {
      lowPerformanceMode = true;
      document.getElementById('webgl-error').classList.add('hidden');
      
      // Réinitialiser le renderer avec des paramètres simplifiés
      if (renderer) {
        renderer.dispose();
        container.removeChild(renderer.domElement);
      }
      
      // Recréer un renderer avec des options de performance basiques
      renderer = new THREE.WebGLRenderer({
        antialias: false,
        powerPreference: 'default',
        alpha: false
      });
      renderer.setPixelRatio(1); // Force à 1 pour économiser les ressources
      renderer.setSize(window.innerWidth, window.innerHeight);
      container.appendChild(renderer.domElement);
      
      // Réduire la complexité de la scène
      if (scene) {
        // Supprimer la grille
        scene.children.forEach(child => {
          if (child instanceof THREE.GridHelper) {
            scene.remove(child);
          }
        });
        
        // Réduire la portée du brouillard
        if (scene.fog) {
          scene.fog.near = 10;
          scene.fog.far = 50;
        }
      }
      
      // Simplifier la caméra
      camera.far = 50;
      camera.updateProjectionMatrix();
    });
    
    // Initialiser
    init();
    
    function init() {
      container = document.getElementById('robot-scene');
      
      // Configuration de la caméra
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.25, 100);
      camera.position.set(-5, 3, 10);
      camera.lookAt(0, 2, 0);
      
      // Configuration de la scène
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf5f5f5);
      scene.fog = new THREE.Fog(0xf5f5f5, 20, 100);
      
      // Mode sombre
      const setDarkMode = (isDark) => {
        const bgColor = isDark ? 0x121212 : 0xf5f5f5;
        scene.background = new THREE.Color(bgColor);
        scene.fog = new THREE.Fog(bgColor, 20, 100);
      };
      
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        setDarkMode(true);
      }
      
      window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
        setDarkMode(e.matches);
      });
      
      clock = new THREE.Clock();
      
      // Éclairage simplifié
      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x8d8d8d, 3);
      hemiLight.position.set(0, 20, 0);
      scene.add(hemiLight);
      
      // Charge le modèle
      const loader = new GLTFLoader();
      loader.load('/models/gltf/RobotExpressive/RobotExpressive.glb', function(gltf) {
        model = gltf.scene;
        scene.add(model);
        setupAnimations(model, gltf.animations);
      }, undefined, function(e) {
        console.error(e);
      });
      
      // Options du renderer pour maximiser la compatibilité
      const rendererOptions = {
        canvas: document.createElement('canvas'),
        antialias: false, // Désactiver pour les performances
        powerPreference: 'default', // Utiliser default au lieu de high-performance
        failIfMajorPerformanceCaveat: false // Ne pas échouer en cas de problèmes
      };
      
      try {
        // Créer le renderer
        renderer = new THREE.WebGLRenderer(rendererOptions);
        
        // Configuration de base
        renderer.setPixelRatio(1); // Forcer à 1 pour les performances
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);
        
        // Utiliser une fonction animateLoop simple
        lastTime = performance.now();
        animateLoop();
      } catch (error) {
        console.error("Erreur WebGL:", error);
      }
      
      // Responsive
      window.addEventListener('resize', onWindowResize);
      
      // Stats pour debug
      stats = new Stats();
      stats.dom.style.position = 'absolute';
      stats.dom.style.bottom = '0px';
      stats.dom.style.top = 'auto';
      container.appendChild(stats.dom);
    }
    
    function setupAnimations(model, animations) {
      // Configurer le mixer d'animation
      mixer = new THREE.AnimationMixer(model);
      actions = {};
      
      const states = ['Idle', 'Walking', 'Running', 'Dance', 'Death', 'Sitting', 'Standing'];
      const emotes = ['Jump', 'Yes', 'No', 'Wave', 'Punch', 'ThumbsUp'];
      
      // Créer les actions pour chaque animation
      animations.forEach(clip => {
        const action = mixer.clipAction(clip);
        actions[clip.name] = action;
        
        // Configuration pour les animations ponctuelles
        if (emotes.indexOf(clip.name) >= 0 || states.indexOf(clip.name) >= 4) {
          action.clampWhenFinished = true;
          action.loop = THREE.LoopOnce;
        }
      });
      
      // Accéder au modèle de la tête pour les expressions faciales
      face = model.getObjectByName('Head_4');
      
      // Démarrer avec l'animation par défaut
      activeAction = actions['Walking'];
      activeAction.play();
      
      // Exposer les fonctions au niveau global pour l'interface
      window.fadeToAction = fadeToAction;
      window.updateMorphTarget = updateMorphTarget;
    }
    
    function fadeToAction(name, duration) {
      previousAction = activeAction;
      activeAction = actions[name];
      
      if (previousAction !== activeAction) {
        previousAction.fadeOut(duration);
      }
      
      activeAction
        .reset()
        .setEffectiveTimeScale(1)
        .setEffectiveWeight(1)
        .fadeIn(duration)
        .play();
      
      // Pour les animations ponctuelles, revenir à l'état précédent
      if (['Jump', 'Yes', 'No', 'Wave', 'Punch', 'ThumbsUp'].includes(name)) {
        mixer.addEventListener('finished', function onFinished() {
          mixer.removeEventListener('finished', onFinished);
          
          // Revenir à l'animation d'état précédente
          const controlElement = document.querySelector('.robot-control');
          if (controlElement) {
            // Cast to AlpineElement to access __x safely
            const alpineElement = controlElement as unknown as AlpineElement;
            const defaultState = alpineElement.__x?.$data.animationState || 'Walking';
            fadeToAction(defaultState, 0.2);
          } else {
            // Fallback si l'élément n'est pas trouvé
            fadeToAction('Walking', 0.2);
          }
        });
      }
    }
    
    function updateMorphTarget(expressionName, value) {
      if (!face || !face.morphTargetDictionary) return;
      
      // Correspondance entre noms d'expressions et indices du dictionnaire
      const expressionMap = {
        'Angry': face.morphTargetDictionary['Angry'],
        'Surprised': face.morphTargetDictionary['Surprised'], 
        'Sad': face.morphTargetDictionary['Sad'],
        'Happy': face.morphTargetDictionary['Happy'],
        'Relaxed': face.morphTargetDictionary['Relaxed']
      };
      
      // Mettre à jour l'influence du morph target
      const index = expressionMap[expressionName];
      if (index !== undefined) {
        face.morphTargetInfluences[index] = parseFloat(value);
      }
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function animateLoop() {
      requestAnimationFrame(animateLoop);
      
      // Surveiller les performances
      checkPerformance();
      
      // Animation simplifiée pour les mauvaises performances
      const dt = clock.getDelta();
      if (mixer) mixer.update(dt);
      
      // Rendu avec des options adaptées aux performances
      if (scene && camera) {
        renderer.render(scene, camera);
      }
      
      stats.update();
    }
  </script>
</div>
