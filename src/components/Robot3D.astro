---
import RobotControl from "./ui/RobotControl.astro";
---

<div class="robot-container relative w-full min-h-screen overflow-hidden py-8 px-4 sm:px-6">
  <!-- Section d'introduction -->
  <div class="max-w-4xl mx-auto mb-10 text-center">
    <h1 class="text-4xl font-bold mb-4 text-[#E06330]">Astro Robot</h1>
    <p class="text-xl mb-6 text-black dark:text-white">
      Hi, my name is Astro! I'm an interactive 3D robot that you can control.
      Try changing my animations and facial expressions with the control panel.
    </p>
    <p class="text-lg mb-6 text-black dark:text-white">
      You can drag the control panel anywhere on the screen, select different animations, 
      or adjust my facial expressions to make me happy, sad, angry, surprised, or relaxed!
    </p>
    <div class="inline-block bg-[#120D16] border border-[#E06330] text-white text-sm px-4 py-2 rounded-lg">
      <span class="font-medium">Tip:</span> If you experience performance issues, try the "Simplified mode" option when prompted.
    </div>
  </div>

  <RobotControl />
  
  <div id="robot-scene" class="w-full h-[70vh] mt-4">
    <!-- Le conteneur pour la scène 3D -->
  </div>
  
  <div id="webgl-error" class="hidden absolute inset-0 bg-black bg-opacity-80 flex items-center justify-center p-4 z-50">
    <div class="bg-[#120D16] border border-[#E06330] p-6 rounded-lg max-w-md text-center">
      <h3 class="text-xl font-bold text-white mb-3">3D performance problem</h3>
      <p class="text-gray-300 mb-4">3D visualization does not work properly on your browser.</p>
      <div class="flex space-x-4 justify-center">
        <button id="try-fallback" class="bg-[#E06330] hover:bg-orange-600 text-white px-4 py-2 rounded-md transition-colors">
          Simplified mode
        </button>
        <button id="close-error" class="bg-gray-700 hover:bg-gray-600 text-white px-4 py-2 rounded-md transition-colors">
          Go on
        </button>
      </div>
    </div>
  </div>
  
  <script>
    // Exposer les fonctions pour l'interface de contrôle
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import Stats from 'three/addons/libs/stats.module.js';

    let container: HTMLElement | null = null;
    let stats: Stats, clock: THREE.Clock, mixer: THREE.AnimationMixer, actions: {[key: string]: THREE.AnimationAction}, 
        activeAction: THREE.AnimationAction, previousAction: THREE.AnimationAction;
    let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, 
        model: THREE.Object3D, face: THREE.Mesh & {morphTargetDictionary?: {[key: string]: number}, morphTargetInfluences?: number[]};
    let lowPerformanceMode = false;
    let frameCount = 0;
    let lastTime = 0;
    let currentFPS = 0;
    
    // Fonction pour détecter les problèmes de performance
    function checkPerformance() {
      const now = performance.now();
      frameCount++;
      
      // Calculer le FPS toutes les secondes
      if (now - lastTime >= 1000) {
        currentFPS = frameCount;
        frameCount = 0;
        lastTime = now;
        
        // Si le FPS est très bas après quelques secondes, proposer une alternative
        if (currentFPS < 15 && !lowPerformanceMode) {
          const errorElement = document.getElementById('webgl-error');
          if (errorElement) errorElement.classList.remove('hidden');
        }
      }
    }
    
    // Gestion du message d'erreur
    const closeErrorBtn = document.getElementById('close-error');
    if (closeErrorBtn) {
      closeErrorBtn.addEventListener('click', () => {
        const errorElement = document.getElementById('webgl-error');
        if (errorElement) errorElement.classList.add('hidden');
      });
    }
    
    const tryFallbackBtn = document.getElementById('try-fallback');
    if (tryFallbackBtn) {
      tryFallbackBtn.addEventListener('click', () => {
        lowPerformanceMode = true;
        const errorElement = document.getElementById('webgl-error');
        if (errorElement) errorElement.classList.add('hidden');
        
        // Réinitialiser le renderer avec des paramètres simplifiés
        if (renderer && container) {
          renderer.dispose();
          container.removeChild(renderer.domElement);
          
          // Recréer un renderer avec des options de performance basiques
          renderer = new THREE.WebGLRenderer({
            antialias: false,
            powerPreference: 'default',
            alpha: true
          });
          renderer.setPixelRatio(1); // Force à 1 pour économiser les ressources
          renderer.setSize(window.innerWidth, window.innerHeight);
          container.appendChild(renderer.domElement);
          
          // Réduire la complexité de la scène
          if (scene) {
            // Réduire la portée du brouillard pour un meilleur rendu sans arrière-plan
            if (scene.fog) {
              scene.fog.near = 10;
              scene.fog.far = 50;
            }
          }
          
          // Simplifier la caméra
          camera.far = 50;
          camera.updateProjectionMatrix();
        }
      });
    }
    
    // Initialiser
    init();
    
    function init() {
      container = document.getElementById('robot-scene');
      if (!container) return;
      
      // Configuration de la caméra
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.25, 100);
      camera.position.set(-5, 3, 10);
      camera.lookAt(0, 2, 0);
      
      // Configuration de la scène
      scene = new THREE.Scene();
      // Utiliser un fond transparent mais garder le sol
      scene.background = null;
      scene.fog = null;
      
      // Mode sombre - modifie uniquement l'éclairage, pas l'arrière-plan
      const setDarkMode = (isDark: boolean) => {
        // Ajuster l'intensité de la lumière en fonction du mode
        if (scene.children) {
          scene.children.forEach(child => {
            if (child instanceof THREE.Light) {
              child.intensity = isDark ? 2 : 3;
            }
            // Ne plus ajuster la couleur du sol en fonction du mode
            // car nous utilisons maintenant une couleur orange fixe
          });
        }
      };
      
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        setDarkMode(true);
      }
      
      window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
        setDarkMode(e.matches);
      });
      
      clock = new THREE.Clock();
      
      // Éclairage optimisé
      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x8d8d8d, 3);
      hemiLight.position.set(0, 20, 0);
      scene.add(hemiLight);
      
      // Ajouter une lumière directionnelle pour de meilleures ombres
      const dirLight = new THREE.DirectionalLight(0xffffff, 2);
      dirLight.position.set(-5, 10, 7);
      dirLight.castShadow = true;
      scene.add(dirLight);
      
      // Ajouter uniquement le sol
      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(20, 20),
        new THREE.MeshPhongMaterial({ 
          color: 0xDD612F, // Couleur orange #DD612F
          depthWrite: false,
          transparent: true,
          opacity: 0.67 // 67% d'opacité
        })
      );
      floor.rotation.x = -Math.PI / 2; // Horizontal
      floor.position.y = -0.01; // Légèrement sous le robot pour éviter les z-fighting
      floor.receiveShadow = true;
      floor.userData.isFloor = true; // Marqueur pour l'identifier plus tard
      scene.add(floor);
      
      // Charge le modèle
      const loader = new GLTFLoader();
      loader.load('/models/gltf/RobotExpressive/RobotExpressive.glb', function(gltf) {
        model = gltf.scene;
        // Activer les ombres pour le modèle
        model.traverse((object) => {
          if (object instanceof THREE.Mesh) {
            object.castShadow = true;
            object.receiveShadow = true;
          }
        });
        scene.add(model);
        setupAnimations(model, gltf.animations);
      }, undefined, function(e) {
        console.error(e);
      });
      
      // Options du renderer pour la transparence avec ombres
      const rendererOptions = {
        canvas: document.createElement('canvas'),
        antialias: true,
        powerPreference: 'default',
        alpha: true, // Activer la transparence
        premultipliedAlpha: true,
        failIfMajorPerformanceCaveat: false
      };
      
      try {
        // Créer le renderer
        renderer = new THREE.WebGLRenderer(rendererOptions);
        
        // Configuration pour la transparence et les ombres
        renderer.setClearColor(0x000000, 0); // Transparent
        renderer.setPixelRatio(window.devicePixelRatio > 1 ? 2 : 1);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);
        
        // Utiliser une fonction animateLoop simple
        lastTime = performance.now();
        animateLoop();
      } catch (error) {
        console.error("Erreur WebGL:", error);
      }
      
      // Responsive
      window.addEventListener('resize', onWindowResize);
      
      // Stats pour debug
      stats = new Stats();
      stats.dom.style.position = 'absolute';
      stats.dom.style.bottom = '0px';
      stats.dom.style.top = 'auto';
      container.appendChild(stats.dom);
    }
    
    function setupAnimations(model: THREE.Object3D, animations: THREE.AnimationClip[]) {
      // Configurer le mixer d'animation
      mixer = new THREE.AnimationMixer(model);
      actions = {};
      
      const states = ['Idle', 'Walking', 'Running', 'Dance', 'Death', 'Sitting', 'Standing'];
      const emotes = ['Jump', 'Yes', 'No', 'Wave', 'Punch', 'ThumbsUp'];
      
      // Créer les actions pour chaque animation
      animations.forEach(clip => {
        const action = mixer.clipAction(clip);
        actions[clip.name] = action;
        
        // Configuration pour les animations ponctuelles
        if (emotes.indexOf(clip.name) >= 0 || states.indexOf(clip.name) >= 4) {
          action.clampWhenFinished = true;
          action.loop = THREE.LoopOnce;
        }
      });
      
      // Accéder au modèle de la tête pour les expressions faciales
      face = model.getObjectByName('Head_4');
      
      // Démarrer avec l'animation par défaut
      activeAction = actions['Walking'];
      activeAction.play();
    }
    
    function fadeToAction(name: string, duration: number) {
      previousAction = activeAction;
      activeAction = actions[name];
      
      if (previousAction !== activeAction) {
        previousAction.fadeOut(duration);
      }
      
      activeAction
        .reset()
        .setEffectiveTimeScale(1)
        .setEffectiveWeight(1)
        .fadeIn(duration)
        .play();
      
      // Pour les animations ponctuelles, revenir à l'état précédent
      if (['Jump', 'Yes', 'No', 'Wave', 'Punch', 'ThumbsUp'].includes(name)) {
        mixer.addEventListener('finished', function onFinished() {
          mixer.removeEventListener('finished', onFinished);
          
          // Revenir à l'animation d'état précédente
          const controlElement = document.querySelector('.robot-control');
          if (controlElement) {
            // Cast to AlpineElement to access __x safely
            const alpineElement = controlElement as unknown as AlpineElement;
            const defaultState = alpineElement.__x?.$data.animationState || 'Walking';
            fadeToAction(defaultState, 0.2);
          } else {
            // Fallback si l'élément n'est pas trouvé
            fadeToAction('Walking', 0.2);
          }
        });
      }
    }
    
    function updateMorphTarget(expressionName: string, value: string | number) {
      if (!face || !face.morphTargetDictionary || !face.morphTargetInfluences) return;
      
      // Correspondance entre noms d'expressions et indices du dictionnaire
      const expressionMap: {[key: string]: number | undefined} = {
        'Angry': face.morphTargetDictionary['Angry'],
        'Surprised': face.morphTargetDictionary['Surprised'], 
        'Sad': face.morphTargetDictionary['Sad'],
        'Happy': face.morphTargetDictionary['Happy'],
        'Relaxed': face.morphTargetDictionary['Relaxed']
      };
      
      // Mettre à jour l'influence du morph target
      const index = expressionMap[expressionName];
      if (index !== undefined) {
        face.morphTargetInfluences[index] = parseFloat(value.toString());
      }
    }
    
    function onWindowResize() {
      if (!renderer) return;
      
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function animateLoop() {
      requestAnimationFrame(animateLoop);
      
      // Surveiller les performances
      checkPerformance();
      
      // Animation simplifiée pour les mauvaises performances
      const dt = clock.getDelta();
      if (mixer) mixer.update(dt);
      
      // Rendu avec des options adaptées aux performances
      if (scene && camera && renderer) {
        renderer.render(scene, camera);
      }
      
      stats.update();
    }

    // Déclarer l'interface pour les types globaux
    declare global {
      interface Window {
        fadeToAction: (name: string, duration: number) => void;
        updateMorphTarget: (expressionName: string, value: string | number) => void;
      }
    }

    // Exposer les fonctions au niveau global
    window.fadeToAction = fadeToAction;
    window.updateMorphTarget = updateMorphTarget;
  </script>
</div>
